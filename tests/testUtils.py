'''
This utility class reads in and stores the Matlab saved results as well as
the mappings between pyradiomics feature names and Matlab feature names
(generated by namesMatcher.py), as well as the manually generated
matlab2pyradiomics_<feature_class>.txt file.
It provides utility methods to get the baseline Matlab feature value for a
feature class.
'''

import SimpleITK as sitk
import sys, os
import csv
import logging
import math
from nose_parameterized import parameterized

class RadiomicsTestUtils:

  def __init__(self):
    # set if output should be verbose for debugging
    self.logger = logging.getLogger('testUtils')
    self.logger.setLevel(logging.ERROR)
    # self.logger.setLevel(logging.DEBUG)

    self.logger.debug('RadiomicsTestUtils')

    # the image and mask volumes
    self.image = None
    self.mask = None

    # set up file paths
    self.dataDir = os.path.join(os.path.dirname(os.path.abspath(__file__)),"..","data")
    self.mappingDir = os.path.join(self.dataDir,'mapping')

    self.matlabFeaturesFile = os.path.join(self.dataDir,'MatlabFeatures.csv')
    self.matlab2PyradiomicsFeatureClassesFile = os.path.join(self.mappingDir, 'matlab2pyradiomics_featureClasses.txt')
    self.matlab2PyradiomicsFile = None
    self.matlabIndicesFile = None
    self.pyradiomicsIndicesFile = None

    self.featureClassName = None
    self.matlabFeatureClassName = None
    self.baselineFeatures = {}
    self.matlab2PyradiomicsFeatureClasses = {}
    self.matlab2PyradiomicsIndices = {}
    self.pyradiomics2MatlabIndices = {}
    self.matlabIndices = {}
    self.pyradiomicsIndices = {}

    self.testCase = None

    self.sigma = 0.0

    self.doWavelets = False
    self.waveletString = None

    self.readMatlabFeatures()

    self.readMatlab2PyradiomicsFeatureClasses()

    self.results = {}
    self.diffs = {}

  #
  # Set up the feature class, read in the files associated with it.
  # Also sets the matlab feature class that maps to this one.
  # Returns false if the feature class name didn't change, true if it did.
  #
  def setFeatureClassName(self, className):
    if self.featureClassName == className:
      return False

    self.logger.debug('Setting feature class name to %s', className)

    self.featureClassName = className

    self.matlab2PyradiomicsFile = os.path.join(self.mappingDir,'matlab2pyradiomics_'+self.featureClassName+'.txt')
    self.matlabIndicesFile = os.path.join(self.mappingDir,'matlab_'+self.featureClassName+'.txt')
    self.pyradiomicsIndicesFile = os.path.join(self.mappingDir,'pyradiomics_'+self.featureClassName+'.txt')

    self.readMatlabIndices()
    self.readRadiomicsIndices()
    self.readMatlab2Pyradiomics()

    pyradFeatureClassIndex = self.matlab2PyradiomicsFeatureClasses.values().index(className)
    self.matlabFeatureClassName = self.matlab2PyradiomicsFeatureClasses.keys()[pyradFeatureClassIndex]
    self.logger.debug("pyradFeatureClassIndex = %d, matlabFeatureClassName = %s", pyradFeatureClassIndex, self.matlabFeatureClassName)


    return True

  #
  # Set up the variables for a specific test case:
  # - set the testCase var to match the string that joins the baseline file line, the image name, the mask name
  # - if this is a different test case from a previous valid one, read in the image and mask and return True
  # - if no change, return False
  def setTestCase(self, testCase):
    self.logger.debug('testUtils setTestCase: %s', testCase)
    if self.testCase != testCase:
      imageName = os.path.join(self.dataDir, testCase + '_image.nrrd')
      maskName = os.path.join(self.dataDir, testCase + '_label.nrrd')

      self.logger.info("Reading the image and mask for test case %s", testCase)
      self.image = sitk.ReadImage(imageName)
      self.mask = sitk.ReadImage(maskName)
      self.results[testCase] = {}
      self.diffs[testCase] = {}
      self.testCase = testCase
      return True
    else:
      return False

  def getTestCase(self):
    return self.testCase

  #
  # Set the LoG sigma value, returning True if it changed.
  #
  def setSigma(self, sigma):
    self.logger.debug('testUtils setSigma: %f', sigma)
    if self.sigma != sigma:
      self.sigma = sigma
      return True
    else:
      return False

  def getSigma(self):
    return self.sigma

  def getImage(self):
    return self.image
  def getMask(self):
    return self.mask

  #
  # Return all the test cases for which there are baseline information.
  #
  def getTestCases(self):
    return self.baselineFeatures.keys()

  #
  # Return the sigma values that were used in the baseline calculations
  # for the Laplacian operator
  # For now, hard coded from 0.5 to 5.0 in steps of 0.5.
  # To do: generate from the Matlab features list:
  # laplacian_sigma_[?|?_?]_mm_[2|3]D_FEATURECLASS_FEATURENAME
  #
  def getLaplacianSigmas(self):
    sigmas = []
    s = 0.5
    while s <= 5.0:
      sigmas.append(s)
      s += 0.5
    return sigmas

  #
  # For the baseline column headers, the floating point sigma values
  # are replaced as strings that use an underscore instead of a decimal
  # point and don't include the zero. This calls getLaplacianSigmas
  # and then iterates over the array to create an array of strings
  # via calling getLaplacianSigmaString
  #
  def getLaplacianSigmaStrings(self):
    sigmaStrings = []
    sigmas = self.getLaplacianSigmas()
    for i in range(len(sigmas)):
      s = sigmas[i]
      stringSigma = self.getLaplacianSigmaString(s)
      sigmaStrings.append(stringSigma)
    return sigmaStrings

  #
  # Convert floating point sigma to a string.
  # For the baseline column headers, the floating point sigma values
  # are replaced as strings that use an underscore instead of a decimal
  # point and don't include the zero.
  #
  def getLaplacianSigmaString(self, sigma):
    stringSigma = str(sigma).replace(".", "_")
    # the variable names don't include the _0 on integers
    if "_0" in stringSigma:
      stringSigma = stringSigma[0:len(stringSigma)-2]
    return stringSigma

  #
  # A custom test name function that will ensure that the tests are run
  # such that they're batched with all tests for a given data set are run
  # together, avoiding re-reading the data more than necessary.
  # Tests are run in alphabetical order, so put the test case first.
  # An alternate option is to right justify the test number (param_num)
  # with zeroes so that the numerical and alphabetical orders are the same
  # Not providing this method when there are more than 10 tests results in
  # tests running in an order similar to:
  # test_*.test_scenario_0_*
  # test_*.test_scenario_10_*
  # test_*.test_scenario_11_*
  # ...
  # test_*.test_scenario_19_*
  # test_*.test_scenario_1_*
  # test_*.test_scenario_20_*
  #
  def custom_name_func(self, testcase_func, param_num, param):
    self.logger.debug('custom_name_func: function name = %s, param_num = {0:0>3}, param.args = %s'.format(param_num), testcase_func.__name__, param.args)
    return "%s_%s" %(
        testcase_func.__name__,
        parameterized.to_safe_name("_".join(str(x) for x in param.args)),
        )
  #
  # Read in the matlab features file and store the baseline information
  # for the test cases.
  #
  def readMatlabFeatures(self):
    if (not os.path.exists(self.matlabFeaturesFile)):
      self.logger.error('Matlab features file not found %s:',self.matlabFeaturesFile)
      return
    self.baselineFeatures = {}
    csvFile = open(self.matlabFeaturesFile, 'rb')
    csvFileReader = csv.reader(csvFile)
    # get the column headers
    headerRow = csvFileReader.next()
    # iterate over the test cases in the file
    for testRow in csvFileReader:
      testCase = testRow[0]
      self.baselineFeatures[testCase] = {}
      self.logger.debug('Reading baseline for test case %s',testCase)
      columnIndex = 0
      for val in testRow:
        self.baselineFeatures[testCase][headerRow[columnIndex]] = val
        columnIndex += 1


  #
  # Read in the file that maps between matlab feature names and pyradiomics
  # feature names
  #
  def readMatlab2PyradiomicsFeatureClasses(self):
    if (not os.path.exists(self.matlab2PyradiomicsFeatureClassesFile)):
      self.logger.error('Matlab features to Pyradiomics features mapping file not found %s:',self.matlab2PyradiomicsFeatureClassesFile)
      return
    self.matlab2PyradiomicsFeatureClasses = {}
    mappingFile = open(self.matlab2PyradiomicsFeatureClassesFile, 'rb')
    for line in mappingFile:
      matlabPy = line.rstrip().split(':')
      m = matlabPy[0]
      p = matlabPy[1]
      self.matlab2PyradiomicsFeatureClasses[m] = p
    self.logger.debug('readMatlab2PyradomicsFeatures: mapping = %s',self.matlab2PyradiomicsFeatureClasses)

  #
  # Read in the file that maps matlab feature indices to matlab feature names
  #
  def readMatlabIndices(self):
    if (not os.path.exists(self.matlabIndicesFile)):
      self.logger.error('Matlab indices to feature names file not found: %s',self.matlabIndicesFile)
      return
    self.matlabIndices = {}
    mappingFile = open(self.matlabIndicesFile, 'rb')
    for line in mappingFile:
      indexFeature = line.rstrip().split(':')
      index = int(indexFeature[0])
      feature = indexFeature[1]
      self.matlabIndices[index] = feature
    self.logger.debug('readMatlabIndices: matlabIndices = %s',self.matlabIndices)

  #
  # Read in the file that maps radiomics feature indices to radiomics feature names
  #
  def readRadiomicsIndices(self):
    if (not os.path.exists(self.pyradiomicsIndicesFile)):
      self.logger.error('Radiomics indices to feature names file not found: %s',self.pyradiomicsIndicesFile)
      return
    self.pyradiomicsIndices = {}
    mappingFile = open(self.pyradiomicsIndicesFile, 'rb')
    for line in mappingFile:
      indexFeature = line.rstrip().split(':')
      index = int(indexFeature[0])
      feature = indexFeature[1]
      self.pyradiomicsIndices[feature] = index
    self.logger.debug('readRadiomicsIndices: pyradiomicsIndices = %s',self.pyradiomicsIndices)

  #
  # Read and parse the file that gives the mapping between matlab feature
  # incides and pyradiomics feature indices
  #
  def readMatlab2Pyradiomics(self):
    if (not os.path.exists(self.matlab2PyradiomicsFile)):
      self.logger.error('Matlab to pyradiomics feature indices mapping file not found: %s',self.matlab2PyradiomicsFile)
      return
    self.matlab2PyradiomicsIndices = {}
    self.pyradiomics2MatlabIndices = {}
    mappingFile = open(self.matlab2PyradiomicsFile, 'rb')
    for line in mappingFile:
       m2pyrad = line.rstrip().split(':')
       matlabIndex = int(m2pyrad[0])
       pyradIndex = int(m2pyrad[1])
       self.pyradiomics2MatlabIndices[pyradIndex] = matlabIndex
       self.matlab2PyradiomicsIndices[matlabIndex] = pyradIndex
    self.logger.debug('readMatlab2Pyradiomics:')
    self.logger.debug('\tpyradiomcs 2 matlab indices = %s',self.pyradiomics2MatlabIndices)
    self.logger.debug('\tmatlab 2 pyradiomics indices = %s',self.matlab2PyradiomicsIndices)

  #
  # Search the pyradiomicsIndices for the passed in pyradiomicsKey
  # and return the index. Returns -1 if not found
  #
  def getPyradiomicsIndex(self, pyradiomicsKey):
    pyradiomicsIndex = -1
    if pyradiomicsKey in self.pyradiomicsIndices:
      self.logger.debug('getPyradiomicsIndex: key is in the indices list: %s',pyradiomicsKey)
      pyradiomicsIndex = self.pyradiomicsIndices[pyradiomicsKey]
    return pyradiomicsIndex

  #
  # Get the matching matlab index for the given pyradiomics index.
  # Returns -1 if not found.
  #
  def getMatlabIndexFromPyradIndex(self, pyradIndex):
    matlabIndex = -1
    if pyradIndex in self.pyradiomics2MatlabIndices:
        matlabIndex = self.pyradiomics2MatlabIndices[pyradIndex]
    return matlabIndex

  #
  # Find the feature name for the matlab feature with matlabIndex.
  # Returns None on failure.
  #
  def getMatlabFeatureName(self, matlabIndex):
    featureName = None
    if matlabIndex in self.matlabIndices:
      featureName = self.matlabIndices[matlabIndex]
    return featureName

  #
  # From the given pyradiomics feature name, get the full string with the feature class
  # and any LoG or wavelet setting strings, to be used to index into the baseline
  # features dictionary. Relies on the pyradomics featureClassName having been set in this utility class.
  #
  def getBaselineFeatureClassAndName(self, pyradFeatureName):
    self.logger.debug('getBaselineFeatureClassAndName: pyradFeatureName = %s', pyradFeatureName)
    matlabFeatureName = self.getMatlabFeatureNameFromPyradiomicsFeatureName(pyradFeatureName)
    self.logger.debug('getBaselineFeatureClassAndName: matlabFeatureName = %s', matlabFeatureName)
    featureName = None
    if self.getSigma() > 0.0:
      sigmaString = self.getLaplacianSigmaString(self.getSigma())
      self.logger.debug('getBaselineFeatureClassAndName: using sigma of %f, string = %s',self.getSigma(), sigmaString)
      # sitk only does 3D
      featureName = 'laplacian_sigma_' + sigmaString + '_mm_3D_' + self.matlabFeatureClassName + '_' + matlabFeatureName
    elif self.doWavelets:
      featureName = 'wavelet_' + self.waveletString + '_' + self.matlabFeatureClassName + '_' + matlabFeatureName
    else:
      featureName = self.matlabFeatureClassName + '_' + matlabFeatureName
    return featureName

  #
  # From the given pyradiomics feature name, check that the currently set
  # testCase has an entry in the baseline features dictionary. If so,
  # find the matching matlab key and return the baseline feature value for
  # the currently set test case ID.
  #
  def getBaselineFeatureValue(self, pyradFeatureName):
    assert(self.getTestCase() in self.baselineFeatures)
    self.logger.debug('getBaselineFeatureValue: Test case %s has baseline information', self.getTestCase())

    featureName = self.getBaselineFeatureClassAndName(pyradFeatureName)

    # Check if the feature name is in the baseline
    self.logger.debug('\tfeature name = %s', featureName)
    if not (featureName in self.baselineFeatures[self.getTestCase()]):
      self.logger.error('getBaselineFeatureValue: feature %s does not appear in the Matlab baseline file for this test case', featureName)
    assert(featureName in self.baselineFeatures[self.getTestCase()])
    self.logger.debug('getBaselineFeatureValue: Matlab feature %s is in the baseline for this test case', featureName)

    return float(self.baselineFeatures[self.getTestCase()][featureName])

  #
  # Utility method to map between pyradiomics feature name and the matlab feature name.
  # Returns the matlab feature name as a string that can then be used to generate the
  # feature class name plus feature name string for lookup in the baseline.
  #
  def getMatlabFeatureNameFromPyradiomicsFeatureName(self, pyradFeatureName):
    self.logger.debug('getMatlabFeatureNameFromPyradiomicsFeatureName: pyradiomics feature name = %s', pyradFeatureName)

    # get the index of this pyradoimics feature name
    pyradIndex = self.getPyradiomicsIndex(pyradFeatureName)
    self.logger.debug('getMatlabFeatureNameFromPyradiomicsFeatureName: got pyradindex %d', pyradIndex)
    assert(pyradIndex != -1)

    # now map that index to a matlab index
    matlabIndex = self.getMatlabIndexFromPyradIndex(pyradIndex)
    self.logger.debug('getMatlabFeatureNameFromPyradiomicsFeatureName: got matlab index %d', matlabIndex)
    assert(matlabIndex != -1)

    # now get the matlab feature name for that index
    matlabFeatureName = self.getMatlabFeatureName(matlabIndex)
    self.logger.debug('getMatlabFeatureNameFromPyradiomicsFeatureName: got matlab feature name %s', matlabFeatureName)
    assert(matlabFeatureName != None)
    return matlabFeatureName

  #
  # Use utility methods to get and test the results against the expected baseline value for this key.
  #
  def checkResult(self, key, value):
    assert(value != None)
    assert(not math.isnan(value))

    # save the result using the matlab class and feature names
    self.logger.debug('checkResults: key = %s', key)
    featureName = self.getBaselineFeatureClassAndName(key)
    self.logger.debug('checkResults: featureName = %s', featureName)
    self.results[self.getTestCase()][featureName] = value

    # use the mapping from the utils
    baseline = self.getBaselineFeatureValue(key)
    self.logger.debug('checkResults: for key %s, got baseline = %f', key, baseline)
    if baseline == 0.0:
      # avoid divide by zero, the difference is either 0% if the value is also zero, or 100%
      if value - baseline == 0.0:
        percentDiff = 0.0
      else:
        percentDiff = 1.0
    else:
      percentDiff = abs(1.0 - (value / baseline))

    # save the difference
    self.diffs[self.getTestCase()][featureName] = percentDiff

    # check for a less than three percent difference
    if (percentDiff >= 0.03):
      self.logger.error('checkResult %s, baseline value = %f, calculated = %f, diff = %f%%', key, float(baseline), value, percentDiff * 100)
    assert(percentDiff < 0.03)

  def getResults(self):
    return self.results

  def getDiffs(self):
    return self.diffs

  #
  # Assumes a data structure with:
  # {'id1' : {'f1':n1, 'f2':n2}, 'id2' : {'f1':n3, 'f2':n4}}
  #
  def writeCSV(self, data, fileName):
    csvFile = open(fileName, 'wb')
    csvFileWriter = csv.writer(csvFile)
    # get the headers from the first row
    header = data[data.keys()[0]].keys()
    header = ['testCase'] + header
    csvFileWriter.writerow(header)
    for testCase in data.keys():
      thisCase = data[testCase]
      thisCase['testCase'] = testCase
      row = []
      for h in header:
        row = row + [thisCase[h]]
      csvFileWriter.writerow(row)
    csvFile.close()
    self.logger.info('Wrote to file %s', fileName)
