'''
This utility class reads in and stores the Matlab saved results as well as
the mappings between pyradiomics feature names and Matlab feature names
(generated by namesMatcher.py), as well as the manually generated
matlab2pyradiomics_<feature_class>.txt file.
It provides utility methods to get the baseline Matlab feature value for a
feature class.
'''

import SimpleITK as sitk
import sys, os
import csv
import logging
import math
from nose_parameterized import parameterized

class RadiomicsTestUtils:

  def __init__(self, featureClassName):
    # set if output should be verbose for debugging
    self.logger = logging.getLogger('testUtils')
    self.logger.setLevel(logging.ERROR)
    # self.logger.setLevel(logging.DEBUG)

    self.logger.debug('RadiomicsTestUtils for %s',featureClassName)

    # the image and mask volumes
    self.image = None
    self.mask = None

    # set up file paths
    self.dataDir = os.path.join(os.path.dirname(os.path.abspath(__file__)),"..","data")
    self.mappingDir = os.path.join(self.dataDir,'mapping')

    self.matlabFeaturesFile = os.path.join(self.dataDir,'MatlabFeatures.csv')
    self.matlab2PyradiomicsFile = os.path.join(self.mappingDir,'matlab2pyradiomics_'+featureClassName+'.txt')
    self.matlabIndicesFile = os.path.join(self.mappingDir,'matlab_'+featureClassName+'.txt')
    self.pyradiomicsIndicesFile = os.path.join(self.mappingDir,'pyradiomics_'+featureClassName+'.txt')

    self.featureClass = featureClassName
    self.baselineFeatures = {}
    self.matlab2PyradiomicsIndices = {}
    self.pyradiomics2MatlabIndices = {}
    self.matlabIndices = {}
    self.pyradiomicsIndices = {}

    self.testCase = None

    self.readMatlabFeatures()
    self.readMatlabIndices()
    self.readRadiomicsIndices()
    self.readMatlab2Pyradiomics()

  #
  # Set up the variables for a specific test case:
  # - set the testCase var to match the string that joins the baseline file line, the image name, the mask name
  # - if this is a different test case from a previous valid one, read in the image and mask and return True
  # - if no change, return False
  def setTestCase(self, testCase):
    self.logger.debug('testUtils setTestCase: %s', testCase)
    if self.testCase != testCase:
      imageName = os.path.join(self.dataDir, testCase + '_image.nrrd')
      maskName = os.path.join(self.dataDir, testCase + '_label.nrrd')

      self.logger.info("Reading the image and mask for test case %s", testCase)
      self.image = sitk.ReadImage(imageName)
      self.mask = sitk.ReadImage(maskName)
      self.testCase = testCase
      return True
    else:
      return False

  def getTestCase(self):
    return self.testCase

  def getImage(self):
    return self.image
  def getMask(self):
    return self.mask

  #
  # Return all the test cases for which there are baseline information.
  #
  def getTestCases(self):
    return self.baselineFeatures.keys()

  #
  # A custom test name function that will ensure that the tests are run
  # such that they're batched with all tests for a given data set are run
  # together, avoiding re-reading the data more than necessary.
  # Tests are run in alphabetical order, so put the test case first.
  # An alternate option is to right justify the test number (param_num)
  # with zeroes so that the numerical and alphabetical orders are the same
  # Not providing this method when there are more than 10 tests results in
  # tests running in an order similar to:
  # test_*.test_scenario_0_*
  # test_*.test_scenario_10_*
  # test_*.test_scenario_11_*
  # ...
  # test_*.test_scenario_19_*
  # test_*.test_scenario_1_*
  # test_*.test_scenario_20_*
  #
  def custom_name_func(self, testcase_func, param_num, param):
    self.logger.debug('custom_name_func: function name = %s, param_num = {0:0>3}, param.args = %s'.format(param_num), testcase_func.__name__, param.args)
    return "%s_%s" %(
        testcase_func.__name__,
        parameterized.to_safe_name("_".join(str(x) for x in param.args)),
        )
  #
  # Read in the matlab features file and store the baseline information
  # for the test cases.
  #
  def readMatlabFeatures(self):
    if (not os.path.exists(self.matlabFeaturesFile)):
      self.logger.error('Matlab features file not found %s:',self.matlabFeaturesFile)
      return
    self.baselineFeatures = {}
    csvFile = open(self.matlabFeaturesFile, 'rb')
    csvFileReader = csv.reader(csvFile)
    # get the column headers
    headerRow = csvFileReader.next()
    # iterate over the test cases in the file
    for testRow in csvFileReader:
      testCase = testRow[0]
      self.baselineFeatures[testCase] = {}
      self.logger.debug('Reading baseline for test case %s',testCase)
      columnIndex = 0
      for val in testRow:
        self.baselineFeatures[testCase][headerRow[columnIndex]] = val
        columnIndex += 1


  #
  # Read in the file that maps matlab feature indices to matlab feature names
  #
  def readMatlabIndices(self):
    if (not os.path.exists(self.matlabIndicesFile)):
      self.logger.error('Matlab indices to feature names file not found: %s',self.matlabIndicesFile)
      return
    self.matlabIndices = {}
    mappingFile = open(self.matlabIndicesFile, 'rb')
    for line in mappingFile:
      indexFeature = line.rstrip().split(':')
      index = int(indexFeature[0])
      feature = indexFeature[1]
      self.matlabIndices[index] = feature
    self.logger.debug('readMatlabIndices: matlabIndices = %s',self.matlabIndices)

  #
  # Read in the file that maps radiomics feature indices to radiomics feature names
  #
  def readRadiomicsIndices(self):
    if (not os.path.exists(self.pyradiomicsIndicesFile)):
      self.logger.error('Radiomics indices to feature names file not found: %s',self.pyradiomicsIndicesFile)
      return
    self.pyradiomicsIndices = {}
    mappingFile = open(self.pyradiomicsIndicesFile, 'rb')
    for line in mappingFile:
      indexFeature = line.rstrip().split(':')
      index = int(indexFeature[0])
      feature = indexFeature[1]
      self.pyradiomicsIndices[feature] = index
    self.logger.debug('readRadiomicsIndices: pyradiomicsIndices = %s',self.pyradiomicsIndices)

  #
  # Read and parse the file that gives the mapping between matlab feature
  # incides and pyradiomics feature indices
  #
  def readMatlab2Pyradiomics(self):
    if (not os.path.exists(self.matlab2PyradiomicsFile)):
      self.logger.error('Matlab to pyradiomics feature indices mapping file not found: %s',self.matlab2PyradiomicsFile)
      return
    self.matlab2PyradiomicsIndices = {}
    self.pyradiomics2MatlabIndices = {}
    mappingFile = open(self.matlab2PyradiomicsFile, 'rb')
    for line in mappingFile:
       m2pyrad = line.rstrip().split(':')
       matlabIndex = int(m2pyrad[0])
       pyradIndex = int(m2pyrad[1])
       self.pyradiomics2MatlabIndices[pyradIndex] = matlabIndex
       self.matlab2PyradiomicsIndices[matlabIndex] = pyradIndex
    self.logger.debug('readMatlab2Pyradiomics:')
    self.logger.debug('\tpyradiomcs 2 matlab indices = %s',self.pyradiomics2MatlabIndices)
    self.logger.debug('\tmatlab 2 pyradiomics indices = %s',self.matlab2PyradiomicsIndices)

  #
  # Search the pyradiomicsIndices for the passed in pyradiomicsKey
  # and return the index. Returns -1 if not found
  #
  def getPyradiomicsIndex(self, pyradiomicsKey):
    pyradiomicsIndex = -1
    if pyradiomicsKey in self.pyradiomicsIndices:
      self.logger.debug('getPyradiomicsIndex: key is in the indices list: %s',pyradiomicsKey)
      pyradiomicsIndex = self.pyradiomicsIndices[pyradiomicsKey]
    return pyradiomicsIndex

  #
  # Get the matching matlab index for the given pyradiomics index.
  # Returns -1 if not found.
  #
  def getMatlabIndexFromPyradIndex(self, pyradIndex):
    matlabIndex = -1
    if pyradIndex in self.pyradiomics2MatlabIndices:
        matlabIndex = self.pyradiomics2MatlabIndices[pyradIndex]
    return matlabIndex

  #
  # Find the feature name for the matlab feature with matlabIndex.
  # Returns None on failure.
  #
  def getMatlabFeatureName(self, matlabIndex):
    featureName = None
    if matlabIndex in self.matlabIndices:
      featureName = self.matlabIndices[matlabIndex]
    return featureName

  #
  # From the given matlabFeatureName, check that the currently set
  # testCase has an entry in the baseline features dictionary. If so,
  # return the value of the feature named.
  #
  def getBaselineFeature(self, matlabFeatureName):
    assert(self.getTestCase() in self.baselineFeatures)
    self.logger.debug('getBaselineFeature: Test case %s has baseline information', self.getTestCase())
    featureName = self.featureClass + '_' + matlabFeatureName
    assert(featureName in self.baselineFeatures[self.getTestCase()])
    self.logger.debug('getBaselineFeature: Matlab feature %s is in the baseline for this test case', featureName)
    return float(self.baselineFeatures[self.getTestCase()][featureName])

  #
  # From the given pyradiomics key, find the matching matlab key
  # and return the baseline feature value for the currently set test case
  # ID.
  #
  def getMatlabValue(self, pyradiomicsKey):
    self.logger.debug('getMatlabValue: pyradiomicsKey key = %s', pyradiomicsKey)

    # get the index of this pyradoimics feature name
    pyradIndex = self.getPyradiomicsIndex(pyradiomicsKey)
    self.logger.debug('getMatlabValue: got pyradindex %d', pyradIndex)
    assert(pyradIndex != -1)

    # now map that index to a matlab index
    matlabIndex = self.getMatlabIndexFromPyradIndex(pyradIndex)
    self.logger.debug('getMatlabValue: got matlab index %d', matlabIndex)
    assert(matlabIndex != -1)

    # now get the matlab feature name for that index
    matlabFeatureName = self.getMatlabFeatureName(matlabIndex)
    self.logger.debug('getMatlabValue: got matlab feature name %s', matlabFeatureName)
    assert(matlabFeatureName != None)

    # now get the baseline for this feature for this test case
    return self.getBaselineFeature(matlabFeatureName)

  #
  # Use utility methods to get and test the results against the expected baseline value for this key.
  #
  def checkResult(self, key, value):
    assert(value != None)
    assert(not math.isnan(value))
    # use the mapping from the utils
    baseline = self.getMatlabValue(key)
    self.logger.debug('checkResults: for key %s, got baseline = %f', key, baseline)
    if baseline == 0.0:
      # avoid divide by zero, the difference is either 0% if the value is also zero, or 100%
      if value - baseline == 0.0:
        percentDiff = 0.0
      else:
        percentDiff = 1.0
    else:
      percentDiff = abs(1.0 - (value / baseline))

    # check for a less than one percent difference
    if (percentDiff >= 0.01):
      self.logger.error('checkResult %s, baseline value = %f, calculated = %f, diff = %f%%', key, float(baseline), value, percentDiff * 100)
    assert(percentDiff < 0.01)

# testUtils = RadiomicsTestUtils('glcm')
