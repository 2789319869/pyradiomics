'''
This utility class reads in and stores the Matlab saved results as well as
additional baseline results and the mappings between pyradiomics feature names
and baseline feature names (generated by namesMatcher.py), as well as
the manually generated baseline2pyradiomics_<feature_class>.txt file.
It provides utility methods to get the baseline feature value for a
feature class and compare it to the result generated by the test.
'''

import SimpleITK as sitk
import sys, os
import csv
import logging
import math
import numpy
from nose_parameterized import parameterized
from radiomics import imageoperations

class RadiomicsTestUtils:

  def __init__(self):
    # set if output should be verbose for debugging
    self.logger = logging.getLogger('testUtils')
    self.logger.setLevel(logging.ERROR)
    # self.logger.setLevel(logging.DEBUG)

    self.logger.debug('RadiomicsTestUtils')

    # the image and mask volumes
    self.image = None
    self.mask = None

    # resampling settings
    self.interpolator = None
    self.resampledPixelSpacing = None

    # set up file paths
    self.dataDir = os.path.join(os.path.dirname(os.path.abspath(__file__)),"..","data")
    self.mappingDir = os.path.join(self.dataDir,'mapping')

    self.matlabFeaturesFile = os.path.join(self.dataDir,'MatlabBaselineFeatures.csv')
    self.addBaselineFeaturesFile = os.path.join(self.dataDir, 'AdditionalBaselineFeatures.csv')

    self.baseline2PyradiomicsFeatureClassesFile = os.path.join(self.mappingDir, 'baseline2pyradiomics_featureClasses.txt')
    self.baseline2PyradiomicsFile = None
    self.baselineIndicesFile = None
    self.pyradiomicsIndicesFile = None

    self.featureClassName = None
    self.baselineFeatureClassName = None
    self.baselineFeatures = {}
    self.baseline2PyradiomicsFeatureClasses = {}
    self.baseline2PyradiomicsIndices = {}
    self.pyradiomics2baselineIndices = {}
    self.baselineIndices = {}
    self.pyradiomicsIndices = {}

    self.testCase = None

    self.sigma = 0.0

    self.doWavelets = False
    self.waveletString = None

    self.baselineFeatures = self.readBaselineFeatures(self.matlabFeaturesFile)
    if os.path.exists(self.addBaselineFeaturesFile):
      for testCase, testVals in self.readBaselineFeatures(self.addBaselineFeaturesFile).iteritems():
        if testCase in self.baselineFeatures:
          self.baselineFeatures[testCase].update(testVals)
        else:
          self.baselineFeatures[testCase] = testVals

    self.readBaseline2PyradiomicsFeatureClasses()

    self.results = {}
    self.diffs = {}

  def setResampling(self, interpolator, resampledPixelSpacing):
    self.interpolator = interpolator
    self.resampledPixelSpacing = resampledPixelSpacing

  #
  # Set up the feature class, read in the files associated with it.
  # Also sets the baseline feature class that maps to this one.
  # Returns false if the feature class name didn't change, true if it did.
  #
  def setFeatureClassName(self, className):
    if self.featureClassName == className:
      return False

    self.logger.debug('Setting feature class name to %s', className)

    self.featureClassName = className

    self.baseline2PyradiomicsFile = os.path.join(self.mappingDir,'baseline2pyradiomics_'+self.featureClassName+'.txt')
    self.baselineIndicesFile = os.path.join(self.mappingDir,'baseline_'+self.featureClassName+'.txt')
    self.pyradiomicsIndicesFile = os.path.join(self.mappingDir,'pyradiomics_'+self.featureClassName+'.txt')

    self.readBaselineIndices()
    self.readRadiomicsIndices()
    self.readBaseline2Pyradiomics()

    pyradFeatureClassIndex = self.baseline2PyradiomicsFeatureClasses.values().index(className)
    self.baselineFeatureClassName = self.baseline2PyradiomicsFeatureClasses.keys()[pyradFeatureClassIndex]
    self.logger.debug("pyradFeatureClassIndex = %d, baselineFeatureClassName = %s", pyradFeatureClassIndex, self.baselineFeatureClassName)


    return True

  #
  # Set up the variables for a specific test case:
  # - set the testCase var to match the string that joins the baseline file line, the image name, the mask name
  # - if this is a different test case from a previous valid one, read in the image and mask and return True
  # - if no change, return False
  def setTestCase(self, testCase):
    self.logger.debug('testUtils setTestCase: %s', testCase)
    if self.testCase != testCase:
      imageName = os.path.join(self.dataDir, testCase + '_image.nrrd')
      maskName = os.path.join(self.dataDir, testCase + '_label.nrrd')

      self.logger.info("Reading the image and mask for test case %s", testCase)
      self.image = sitk.ReadImage(imageName)
      self.mask = sitk.ReadImage(maskName)
      if self.interpolator != None and self.resampledPixelSpacing != None:
        self.image, self.mask = imageoperations.resampleImage(self.image, self.mask, self.resampledPixelSpacing, self.interpolator)
      self.results[testCase] = {}
      self.diffs[testCase] = {}
      self.testCase = testCase
      return True
    else:
      return False

  def getTestCase(self):
    return self.testCase

  #
  # Set the LoG sigma value, returning True if it changed.
  #
  def setSigma(self, sigma):
    self.logger.debug('testUtils setSigma: %f', sigma)
    if self.sigma != sigma:
      self.sigma = sigma
      return True
    else:
      return False

  def getSigma(self):
    return self.sigma

  def getImage(self):
    return self.image
  def getMask(self):
    return self.mask

  #
  # Return all the test cases for which there are baseline information.
  #
  def getTestCases(self):
    return self.baselineFeatures.keys()

  #
  # Return the sigma values that were used in the baseline calculations
  # for the Laplacian operator
  # For now, hard coded from 0.5 to 5.0 in steps of 0.5.
  # ToDO: generate from the baseline features list:
  # laplacian_sigma_[?|?_?]_mm_[2|3]D_FEATURECLASS_FEATURENAME
  #
  def getLaplacianSigmas(self):
    sigmas = []
    s = 0.5
    while s <= 5.0:
      sigmas.append(s)
      s += 0.5
    return sigmas

  #
  # For the baseline column headers, the floating point sigma values
  # are replaced as strings that use an underscore instead of a decimal
  # point and don't include the zero. This calls getLaplacianSigmas
  # and then iterates over the array to create an array of strings
  # via calling getLaplacianSigmaString
  #
  def getLaplacianSigmaStrings(self):
    sigmaStrings = []
    sigmas = self.getLaplacianSigmas()
    for i in range(len(sigmas)):
      s = sigmas[i]
      stringSigma = self.getLaplacianSigmaString(s)
      sigmaStrings.append(stringSigma)
    return sigmaStrings

  #
  # Convert floating point sigma to a string.
  # For the baseline column headers, the floating point sigma values
  # are replaced as strings that use an underscore instead of a decimal
  # point and don't include the zero.
  #
  def getLaplacianSigmaString(self, sigma):
    stringSigma = str(sigma).replace(".", "_")
    # the variable names don't include the _0 on integers
    if "_0" in stringSigma:
      stringSigma = stringSigma[0:len(stringSigma)-2]
    return stringSigma

  #
  # A custom test name function that will ensure that the tests are run
  # such that they're batched with all tests for a given data set are run
  # together, avoiding re-reading the data more than necessary.
  # Tests are run in alphabetical order, so put the test case first.
  # An alternate option is to right justify the test number (param_num)
  # with zeroes so that the numerical and alphabetical orders are the same
  # Not providing this method when there are more than 10 tests results in
  # tests running in an order similar to:
  # test_*.test_scenario_0_*
  # test_*.test_scenario_10_*
  # test_*.test_scenario_11_*
  # ...
  # test_*.test_scenario_19_*
  # test_*.test_scenario_1_*
  # test_*.test_scenario_20_*
  #
  def custom_name_func(self, testcase_func, param_num, param):
    self.logger.debug('custom_name_func: function name = %s, param_num = {0:0>3}, param.args = %s'.format(param_num), testcase_func.__name__, param.args)
    return "%s_%s" %(
        testcase_func.__name__,
        parameterized.to_safe_name("_".join(str(x) for x in param.args)),
        )

  #
  # Read in the baseline features file and return the baseline information
  # for the test cases.
  #
  def readBaselineFeatures(self, baselineFeaturesFile):
    if (not os.path.exists(baselineFeaturesFile)):
      self.logger.error('Baseline features file not found %s:',baselineFeaturesFile)
      return {}
    baselineFeatures = {}
    csvFile = open(baselineFeaturesFile, 'rb')
    csvFileReader = csv.reader(csvFile)
    # get the column headers
    headerRow = csvFileReader.next()
    # iterate over the test cases in the file
    for testRow in csvFileReader:
      testCase = testRow[0]
      baselineFeatures[testCase] = {}
      self.logger.debug('Reading additional baseline for test case %s',testCase)
      columnIndex = 0
      for val in testRow:
        baselineFeatures[testCase][headerRow[columnIndex]] = val
        columnIndex += 1
    return baselineFeatures

  #
  # Read in the file that maps between baseline feature names and pyradiomics
  # feature names
  #
  def readBaseline2PyradiomicsFeatureClasses(self):
    if (not os.path.exists(self.baseline2PyradiomicsFeatureClassesFile)):
      self.logger.error('Baseline features to Pyradiomics features mapping file not found %s:',self.baseline2PyradiomicsFeatureClassesFile)
      return
    self.baseline2PyradiomicsFeatureClasses = {}
    mappingFile = open(self.baseline2PyradiomicsFeatureClassesFile, 'rb')
    for line in mappingFile:
      baselinePy = line.rstrip().split(':')
      m = baselinePy[0]
      p = baselinePy[1]
      self.baseline2PyradiomicsFeatureClasses[m] = p
    self.logger.debug('readBaseline2PyradomicsFeatures: mapping = %s',self.baseline2PyradiomicsFeatureClasses)

  #
  # Read in the file that maps baseline feature indices to baseline feature names
  #
  def readBaselineIndices(self):
    if (not os.path.exists(self.baselineIndicesFile)):
      self.logger.error('Baseline indices to feature names file not found: %s',self.baselineIndicesFile)
      return
    self.baselineIndices = {}
    mappingFile = open(self.baselineIndicesFile, 'rb')
    for line in mappingFile:
      indexFeature = line.rstrip().split(':')
      index = int(indexFeature[0])
      feature = indexFeature[1]
      self.baselineIndices[index] = feature
    self.logger.debug('readBaselineIndices: baselineIndices = %s',self.baselineIndices)

  #
  # Read in the file that maps radiomics feature indices to radiomics feature names
  #
  def readRadiomicsIndices(self):
    if (not os.path.exists(self.pyradiomicsIndicesFile)):
      self.logger.error('Radiomics indices to feature names file not found: %s',self.pyradiomicsIndicesFile)
      return
    self.pyradiomicsIndices = {}
    mappingFile = open(self.pyradiomicsIndicesFile, 'rb')
    for line in mappingFile:
      indexFeature = line.rstrip().split(':')
      index = int(indexFeature[0])
      feature = indexFeature[1]
      self.pyradiomicsIndices[feature] = index
    self.logger.debug('readRadiomicsIndices: pyradiomicsIndices = %s',self.pyradiomicsIndices)

  #
  # Read and parse the file that gives the mapping between baseline feature
  # incides and pyradiomics feature indices
  #
  def readBaseline2Pyradiomics(self):
    if (not os.path.exists(self.baseline2PyradiomicsFile)):
      self.logger.error('Baseline to pyradiomics feature indices mapping file not found: %s',self.baseline2PyradiomicsFile)
      return
    self.baseline2PyradiomicsIndices = {}
    self.pyradiomics2BaselineIndices = {}
    mappingFile = open(self.baseline2PyradiomicsFile, 'rb')
    for line in mappingFile:
       b2pyrad = line.rstrip().split(':')
       baselineIndex = int(b2pyrad[0])
       pyradIndex = int(b2pyrad[1])
       self.pyradiomics2BaselineIndices[pyradIndex] = baselineIndex
       self.baseline2PyradiomicsIndices[baselineIndex] = pyradIndex
    self.logger.debug('readBaseline2Pyradiomics:')
    self.logger.debug('\tpyradiomcs 2 baseline indices = %s',self.pyradiomics2BaselineIndices)
    self.logger.debug('\tbaseline 2 pyradiomics indices = %s',self.baseline2PyradiomicsIndices)

  #
  # Search the pyradiomicsIndices for the passed in pyradiomicsKey
  # and return the index. Returns -1 if not found
  #
  def getPyradiomicsIndex(self, pyradiomicsKey):
    pyradiomicsIndex = -1
    if pyradiomicsKey in self.pyradiomicsIndices:
      self.logger.debug('getPyradiomicsIndex: key is in the indices list: %s',pyradiomicsKey)
      pyradiomicsIndex = self.pyradiomicsIndices[pyradiomicsKey]
    return pyradiomicsIndex

  #
  # Get the matching baseline index for the given pyradiomics index.
  # Returns -1 if not found.
  #
  def getBaselineIndexFromPyradIndex(self, pyradIndex):
    baselineIndex = -1
    if pyradIndex in self.pyradiomics2BaselineIndices:
        baselineIndex = self.pyradiomics2BaselineIndices[pyradIndex]
    return baselineIndex

  #
  # Find the feature name for the baseline feature with baselineIndex.
  # Returns None on failure.
  #
  def getBaselineFeatureName(self, baselineIndex):
    featureName = None
    if baselineIndex in self.baselineIndices:
      featureName = self.baselineIndices[baselineIndex]
    return featureName

  #
  # From the given pyradiomics feature name, get the full string with the feature class
  # and any LoG or wavelet setting strings, to be used to index into the baseline
  # features dictionary. Relies on the pyradomics featureClassName having been set in this utility class.
  #
  def getBaselineFeatureClassAndName(self, pyradFeatureName):
    self.logger.debug('getBaselineFeatureClassAndName: pyradFeatureName = %s', pyradFeatureName)
    baselineFeatureName = self.getBaselineFeatureNameFromPyradiomicsFeatureName(pyradFeatureName)
    self.logger.debug('getBaselineFeatureClassAndName: baselineFeatureName = %s', baselineFeatureName)
    featureName = None
    if self.getSigma() > 0.0:
      sigmaString = self.getLaplacianSigmaString(self.getSigma())
      self.logger.debug('getBaselineFeatureClassAndName: using sigma of %f, string = %s',self.getSigma(), sigmaString)
      # sitk only does 3D
      featureName = 'laplacian_sigma_' + sigmaString + '_mm_3D_' + self.baselineFeatureClassName + '_' + baselineFeatureName
    elif self.doWavelets:
      featureName = 'wavelet_' + self.waveletString + '_' + self.baselineFeatureClassName + '_' + baselineFeatureName
    else:
      featureName = self.baselineFeatureClassName + '_' + baselineFeatureName
    return featureName

  #
  # From the given pyradiomics feature name, check that the currently set
  # testCase has an entry in the baseline features dictionary. If so,
  # find the matching baseline key and return the baseline feature value for
  # the currently set test case ID.
  #
  def getBaselineFeatureValue(self, pyradFeatureName):
    assert(self.getTestCase() in self.baselineFeatures)
    self.logger.debug('getBaselineFeatureValue: Test case %s has baseline information', self.getTestCase())

    featureName = self.getBaselineFeatureClassAndName(pyradFeatureName)

    # Check if the feature name is in the baseline
    self.logger.debug('\tfeature name = %s', featureName)
    if not (featureName in self.baselineFeatures[self.getTestCase()]):
      self.logger.error('getBaselineFeatureValue: feature %s does not appear in the baseline file(s) for this test case', featureName)
    assert(featureName in self.baselineFeatures[self.getTestCase()])
    self.logger.debug('getBaselineFeatureValue: Baseline feature %s is in the baseline for this test case', featureName)

    return float(self.baselineFeatures[self.getTestCase()][featureName])

  #
  # Utility method to map between pyradiomics feature name and the baseline feature name.
  # Returns the baseline feature name as a string that can then be used to generate the
  # feature class name plus feature name string for lookup in the baseline.
  #
  def getBaselineFeatureNameFromPyradiomicsFeatureName(self, pyradFeatureName):
    self.logger.debug('getBaselineFeatureNameFromPyradiomicsFeatureName: pyradiomics feature name = %s', pyradFeatureName)

    # get the index of this pyradoimics feature name
    pyradIndex = self.getPyradiomicsIndex(pyradFeatureName)
    self.logger.debug('getBaselineFeatureNameFromPyradiomicsFeatureName: got pyradindex %d', pyradIndex)
    assert(pyradIndex != -1)

    # now map that index to a baseline index
    baselineIndex = self.getBaselineIndexFromPyradIndex(pyradIndex)
    self.logger.debug('getBaselineFeatureNameFromPyradiomicsFeatureName: got baseline index %d', baselineIndex)
    assert(baselineIndex != -1)

    # now get the baseline feature name for that index
    baselineFeatureName = self.getBaselineFeatureName(baselineIndex)
    self.logger.debug('getBaselineFeatureNameFromPyradiomicsFeatureName: got baseline feature name %s', baselineFeatureName)
    assert(baselineFeatureName != None)
    return baselineFeatureName

  #
  # Use utility methods to get and test the results against the expected baseline value for this key.
  #
  def checkResult(self, key, value):
    featureName = self.getBaselineFeatureClassAndName(key)

    assert(value != None)

    if math.isnan(value):
      self.diffs[self.getTestCase()][featureName] = numpy.nan
      self.results[self.getTestCase()][featureName] = numpy.nan
    assert(not math.isnan(value))

    # save the result using the baseline class and feature names
    self.logger.debug('checkResults: key = %s', key)

    self.logger.debug('checkResults: featureName = %s', featureName)
    self.results[self.getTestCase()][featureName] = value

    # use the mapping from the utils
    baseline = self.getBaselineFeatureValue(key)
    self.logger.debug('checkResults: for key %s, got baseline = %f', key, baseline)
    if baseline == 0.0:
      # avoid divide by zero, the difference is either 0% if the value is also zero, or 100%
      if value - baseline == 0.0:
        percentDiff = 0.0
      else:
        percentDiff = 1.0
    else:
      percentDiff = abs(1.0 - (value / baseline))

    # save the difference
    self.diffs[self.getTestCase()][featureName] = percentDiff

    # check for a less than three percent difference
    if (percentDiff >= 0.03):
      self.logger.error('checkResult %s, baseline value = %f, calculated = %f, diff = %f%%', key, float(baseline), value, percentDiff * 100)
    assert(percentDiff < 0.03)

  def getResults(self):
    return self.results

  def getDiffs(self):
    return self.diffs

  #
  # Assumes a data structure with:
  # {'id1' : {'f1':n1, 'f2':n2}, 'id2' : {'f1':n3, 'f2':n4}}
  #
  def writeCSV(self, data, fileName):
    csvFile = open(fileName, 'wb')
    csvFileWriter = csv.writer(csvFile)
    # get the headers from the first row
    header = sorted(data[data.keys()[0]].keys())
    header = ['testCase'] + header
    csvFileWriter.writerow(header)
    for testCase in sorted(data.keys()):
      thisCase = data[testCase]
      thisCase['testCase'] = testCase
      row = []
      for h in header:
        row = row + [thisCase[h]]
      csvFileWriter.writerow(row)
    csvFile.close()
    self.logger.info('Wrote to file %s', fileName)
